# coding: utf-8

"""
    Customer Journey as a Service (CJaaS)

    Something amazing, something special - the Customer Journey as a Service (CJaaS) is a core data layer to enable Journeys across products built upon serverless multi-cloud architecture, to be available as a SaaS service for applications inside and outside of Cisco. [**Cisco Experimental - Not For Production Use**]  # noqa: E501

    OpenAPI spec version: 0.5.0
    Contact: cjaas-earlyaccess@cisco.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def clear_tape(self, authorization, **kwargs):  # noqa: E501
        """Delete All Events Collected within Namespace(i.e Org)  # noqa: E501

        Delete All Events Collected for Org  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_tape(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clear_tape_with_http_info(authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.clear_tape_with_http_info(authorization, **kwargs)  # noqa: E501
            return data

    def clear_tape_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Delete All Events Collected within Namespace(i.e Org)  # noqa: E501

        Delete All Events Collected for Org  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_tape_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_tape" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `clear_tape`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ClearTape', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clear_tape_by_person(self, authorization, person, **kwargs):  # noqa: E501
        """Delete Events Collected on Specific Person  # noqa: E501

        Delete Events on Specific Person  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_tape_by_person(authorization, person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str person: Unique Person ID to filter by (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clear_tape_by_person_with_http_info(authorization, person, **kwargs)  # noqa: E501
        else:
            (data) = self.clear_tape_by_person_with_http_info(authorization, person, **kwargs)  # noqa: E501
            return data

    def clear_tape_by_person_with_http_info(self, authorization, person, **kwargs):  # noqa: E501
        """Delete Events Collected on Specific Person  # noqa: E501

        Delete Events on Specific Person  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_tape_by_person_with_http_info(authorization, person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str person: Unique Person ID to filter by (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'person']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_tape_by_person" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `clear_tape_by_person`")  # noqa: E501
        # verify the required parameter 'person' is set
        if ('person' not in params or
                params['person'] is None):
            raise ValueError("Missing the required parameter `person` when calling `clear_tape_by_person`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person' in params:
            path_params['person'] = params['person']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/ClearTape/{person}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def data_sink(self, body, authorization, **kwargs):  # noqa: E501
        """Data sink accepts events that describe what occurred - when - by whom on every interaction across touchpoints and applications  # noqa: E501

        Data Ingestion is based on Cloud Events specification for describing event data in a common way. Data Sink accepts data in the form of POST or GET with support for both Header based authorization and as-well via Query string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.data_sink(body, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CloudEvent body: (required)
        :param str authorization: SAS Signature (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.data_sink_with_http_info(body, authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.data_sink_with_http_info(body, authorization, **kwargs)  # noqa: E501
            return data

    def data_sink_with_http_info(self, body, authorization, **kwargs):  # noqa: E501
        """Data sink accepts events that describe what occurred - when - by whom on every interaction across touchpoints and applications  # noqa: E501

        Data Ingestion is based on Cloud Events specification for describing event data in a common way. Data Sink accepts data in the form of POST or GET with support for both Header based authorization and as-well via Query string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.data_sink_with_http_info(body, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CloudEvent body: (required)
        :param str authorization: SAS Signature (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_sink" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `data_sink`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `data_sink`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/cloudevents+json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/journey/events', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def data_sink_get(self, sig, data, **kwargs):  # noqa: E501
        """Data sink accepts events that describe what occurred - when - by whom on every interaction across touchpoints and applications  # noqa: E501

        Data Ingestion is based on Cloud Events specification for describing event data in a common way. Data Sink accepts data in the form of POST or GET with support for both Header based authorization and as-well via Query string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.data_sink_get(sig, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sig: SAS Signature within QueryString (required)
        :param str data: CloudEvent Serialized as Base64 UTF8 String (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.data_sink_get_with_http_info(sig, data, **kwargs)  # noqa: E501
        else:
            (data) = self.data_sink_get_with_http_info(sig, data, **kwargs)  # noqa: E501
            return data

    def data_sink_get_with_http_info(self, sig, data, **kwargs):  # noqa: E501
        """Data sink accepts events that describe what occurred - when - by whom on every interaction across touchpoints and applications  # noqa: E501

        Data Ingestion is based on Cloud Events specification for describing event data in a common way. Data Sink accepts data in the form of POST or GET with support for both Header based authorization and as-well via Query string  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.data_sink_get_with_http_info(sig, data, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sig: SAS Signature within QueryString (required)
        :param str data: CloudEvent Serialized as Base64 UTF8 String (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sig', 'data']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method data_sink_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sig' is set
        if ('sig' not in params or
                params['sig'] is None):
            raise ValueError("Missing the required parameter `sig` when calling `data_sink_get`")  # noqa: E501
        # verify the required parameter 'data' is set
        if ('data' not in params or
                params['data'] is None):
            raise ValueError("Missing the required parameter `data` when calling `data_sink_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sig' in params:
            query_params.append(('sig', params['sig']))  # noqa: E501
        if 'data' in params:
            query_params.append(('data', params['data']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/journey/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def identities(self, authorization, id, **kwargs):  # noqa: E501
        """Journeys are built around a concept of Identity. An identity shapes how Journey is connected together. Get Identity by Id  # noqa: E501

        Every event in the Journey has an Identity of the originating individual, different channels can have their own unique Identities, API consumers can tie multiple duplicate Identities together to a unique single individual nondestructively (i.e soft merge) without modifying the Tape. Once aliased, all duplicates are treated as a single Identity for any purpose (Query or View)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identities(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Person ID to clear data (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.identities_with_http_info(authorization, id, **kwargs)  # noqa: E501
        else:
            (data) = self.identities_with_http_info(authorization, id, **kwargs)  # noqa: E501
            return data

    def identities_with_http_info(self, authorization, id, **kwargs):  # noqa: E501
        """Journeys are built around a concept of Identity. An identity shapes how Journey is connected together. Get Identity by Id  # noqa: E501

        Every event in the Journey has an Identity of the originating individual, different channels can have their own unique Identities, API consumers can tie multiple duplicate Identities together to a unique single individual nondestructively (i.e soft merge) without modifying the Tape. Once aliased, all duplicates are treated as a single Identity for any purpose (Query or View)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identities_with_http_info(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Person ID to clear data (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method identities" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `identities`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `identities`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Identities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def identities_alias(self, authorization, id, **kwargs):  # noqa: E501
        """Tie multiple duplicate Identities together to a unique single individual nondestructively (i.e soft merge) without modifying the Tape  # noqa: E501

        Every event in the Journey has an Identity of the originating individual, different channels can have their own unique Identities, API consumers can tie multiple duplicate Identities together to a unique single individual nondestructively (i.e soft merge) without modifying the Tape. Once aliased, all duplicates are treated as a single Identity for any purpose (Query or View)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identities_alias(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Person ID to apply action/query upon (required)
        :param str alias: Unique Person ID to apply action/query upon
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.identities_alias_with_http_info(authorization, id, **kwargs)  # noqa: E501
        else:
            (data) = self.identities_alias_with_http_info(authorization, id, **kwargs)  # noqa: E501
            return data

    def identities_alias_with_http_info(self, authorization, id, **kwargs):  # noqa: E501
        """Tie multiple duplicate Identities together to a unique single individual nondestructively (i.e soft merge) without modifying the Tape  # noqa: E501

        Every event in the Journey has an Identity of the originating individual, different channels can have their own unique Identities, API consumers can tie multiple duplicate Identities together to a unique single individual nondestructively (i.e soft merge) without modifying the Tape. Once aliased, all duplicates are treated as a single Identity for any purpose (Query or View)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identities_alias_with_http_info(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Person ID to apply action/query upon (required)
        :param str alias: Unique Person ID to apply action/query upon
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'id', 'alias']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method identities_alias" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `identities_alias`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `identities_alias`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'alias' in params:
            query_params.append(('alias', params['alias']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Identities/alias', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def identities_delete(self, authorization, id, **kwargs):  # noqa: E501
        """Delete a Identity  # noqa: E501

        Remove a soft merge  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identities_delete(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Person ID to clear data (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.identities_delete_with_http_info(authorization, id, **kwargs)  # noqa: E501
        else:
            (data) = self.identities_delete_with_http_info(authorization, id, **kwargs)  # noqa: E501
            return data

    def identities_delete_with_http_info(self, authorization, id, **kwargs):  # noqa: E501
        """Delete a Identity  # noqa: E501

        Remove a soft merge  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.identities_delete_with_http_info(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Person ID to clear data (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method identities_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `identities_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `identities_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Identities', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def journeys(self, authorization, **kwargs):  # noqa: E501
        """The Tape holds running stream of customer journey events that arrive onto Data Sink from all channels - across mediums  # noqa: E501

        Tape is a append-only, immutable data ledger that can be queried to retrieve snapshot of latest events that moment in time or historically to play-back events as they occurred to understand or analyze Journeys using ML/AI models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.journeys(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str filter: oData Filter Expressions to Slice/Dice Search, ex: type eq 'Add To Cart'
        :param int top: Limit to return latest x events
        :return: list[CloudEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.journeys_with_http_info(authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.journeys_with_http_info(authorization, **kwargs)  # noqa: E501
            return data

    def journeys_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """The Tape holds running stream of customer journey events that arrive onto Data Sink from all channels - across mediums  # noqa: E501

        Tape is a append-only, immutable data ledger that can be queried to retrieve snapshot of latest events that moment in time or historically to play-back events as they occurred to understand or analyze Journeys using ML/AI models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.journeys_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str filter: oData Filter Expressions to Slice/Dice Search, ex: type eq 'Add To Cart'
        :param int top: Limit to return latest x events
        :return: list[CloudEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'filter', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method journeys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `journeys`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Journey', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CloudEvent]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def journeys_by_person(self, authorization, person, **kwargs):  # noqa: E501
        """The Tape holds running stream of customer journey events that arrive onto Data Sink from all channels - across mediums  # noqa: E501

        Tape is a append-only, immutable data ledger that can be queried to retrieve snapshot of latest events that moment in time or historically to play-back events as they occurred to understand or analyze Journeys using ML/AI models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.journeys_by_person(authorization, person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str person: Unique Person ID to filter by (required)
        :param str filter: oData Filter Expressions to Slice/Dice Search, ex: type eq 'Add To Cart'
        :param int top: Limit to return latest x events
        :return: list[CloudEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.journeys_by_person_with_http_info(authorization, person, **kwargs)  # noqa: E501
        else:
            (data) = self.journeys_by_person_with_http_info(authorization, person, **kwargs)  # noqa: E501
            return data

    def journeys_by_person_with_http_info(self, authorization, person, **kwargs):  # noqa: E501
        """The Tape holds running stream of customer journey events that arrive onto Data Sink from all channels - across mediums  # noqa: E501

        Tape is a append-only, immutable data ledger that can be queried to retrieve snapshot of latest events that moment in time or historically to play-back events as they occurred to understand or analyze Journeys using ML/AI models  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.journeys_by_person_with_http_info(authorization, person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str person: Unique Person ID to filter by (required)
        :param str filter: oData Filter Expressions to Slice/Dice Search, ex: type eq 'Add To Cart'
        :param int top: Limit to return latest x events
        :return: list[CloudEvent]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'person', 'filter', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method journeys_by_person" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `journeys_by_person`")  # noqa: E501
        # verify the required parameter 'person' is set
        if ('person' not in params or
                params['person'] is None):
            raise ValueError("Missing the required parameter `person` when calling `journeys_by_person`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person' in params:
            path_params['person'] = params['person']  # noqa: E501

        query_params = []
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Journey/{person}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CloudEvent]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def keys(self, authorization, operation, id, **kwargs):  # noqa: E501
        """Create or Rotate or Delete a Specific Key  # noqa: E501

        With Shared Access Signatures API consumers get choice of granular control on how to access API(paths), which resources to scope(ex:datasink), with what permissions the request needs(read / write), from which  source (ex: website) and how long(10s to 10 years) among many other parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.keys(authorization, operation, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str operation: Key Operation Type: list or create or rotate (required)
        :param str id: Unique Key name as set (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.keys_with_http_info(authorization, operation, id, **kwargs)  # noqa: E501
        else:
            (data) = self.keys_with_http_info(authorization, operation, id, **kwargs)  # noqa: E501
            return data

    def keys_with_http_info(self, authorization, operation, id, **kwargs):  # noqa: E501
        """Create or Rotate or Delete a Specific Key  # noqa: E501

        With Shared Access Signatures API consumers get choice of granular control on how to access API(paths), which resources to scope(ex:datasink), with what permissions the request needs(read / write), from which  source (ex: website) and how long(10s to 10 years) among many other parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.keys_with_http_info(authorization, operation, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str operation: Key Operation Type: list or create or rotate (required)
        :param str id: Unique Key name as set (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'operation', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method keys" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `keys`")  # noqa: E501
        # verify the required parameter 'operation' is set
        if ('operation' not in params or
                params['operation'] is None):
            raise ValueError("Missing the required parameter `operation` when calling `keys`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `keys`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'operation' in params:
            path_params['operation'] = params['operation']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Keys/{operation}/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def keys_delete(self, authorization, id, **kwargs):  # noqa: E501
        """CJaaS APIs are designed to be accessed with Shared Access Signature(SAS) to resources without transmitting any actual sensitive keys(hello! API Keys) or even exchanging a password for a proxy such as oAuth bearer  # noqa: E501

        With Shared Access Signatures API consumers get choice of granular control on how to access API(paths), which resources to scope(ex:datasink), with what permissions the request needs(read / write), from which  source (ex: website) and how long(10s to 10 years) among many other parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.keys_delete(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Key name to delete (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.keys_delete_with_http_info(authorization, id, **kwargs)  # noqa: E501
        else:
            (data) = self.keys_delete_with_http_info(authorization, id, **kwargs)  # noqa: E501
            return data

    def keys_delete_with_http_info(self, authorization, id, **kwargs):  # noqa: E501
        """CJaaS APIs are designed to be accessed with Shared Access Signature(SAS) to resources without transmitting any actual sensitive keys(hello! API Keys) or even exchanging a password for a proxy such as oAuth bearer  # noqa: E501

        With Shared Access Signatures API consumers get choice of granular control on how to access API(paths), which resources to scope(ex:datasink), with what permissions the request needs(read / write), from which  source (ex: website) and how long(10s to 10 years) among many other parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.keys_delete_with_http_info(authorization, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :param str id: Unique Key name to delete (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method keys_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `keys_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `keys_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Keys/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def keys_list(self, authorization, **kwargs):  # noqa: E501
        """List All SAS Keys  # noqa: E501

        With Shared Access Signatures API consumers get choice of granular control on how to access API(paths), which resources to scope(ex:datasink), with what permissions the request needs(read / write), from which  source (ex: website) and how long(10s to 10 years) among many other parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.keys_list(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.keys_list_with_http_info(authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.keys_list_with_http_info(authorization, **kwargs)  # noqa: E501
            return data

    def keys_list_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """List All SAS Keys  # noqa: E501

        With Shared Access Signatures API consumers get choice of granular control on how to access API(paths), which resources to scope(ex:datasink), with what permissions the request needs(read / write), from which  source (ex: website) and how long(10s to 10 years) among many other parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.keys_list_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method keys_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `keys_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Keys/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def online_orchestration_trigger(self, body, person, **kwargs):  # noqa: E501
        """Trigger a Online Orchestration such as Webex Walkin or Display Offer Or Chat Bot to intercept and modify your Customer's Journey Midway  # noqa: E501

        Trigger a Online Orchestration such as Webex Walkin or Display Offer Or Chat Bot to modify your Customer's Journey Midway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.online_orchestration_trigger(body, person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OnlineOrchestration body: (required)
        :param str person: Unique Person ID to filter by (required)
        :param str authorization: Optional SAS Signature within Header
        :param str sig: Optional SAS Signature within QueryString
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.online_orchestration_trigger_with_http_info(body, person, **kwargs)  # noqa: E501
        else:
            (data) = self.online_orchestration_trigger_with_http_info(body, person, **kwargs)  # noqa: E501
            return data

    def online_orchestration_trigger_with_http_info(self, body, person, **kwargs):  # noqa: E501
        """Trigger a Online Orchestration such as Webex Walkin or Display Offer Or Chat Bot to intercept and modify your Customer's Journey Midway  # noqa: E501

        Trigger a Online Orchestration such as Webex Walkin or Display Offer Or Chat Bot to modify your Customer's Journey Midway  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.online_orchestration_trigger_with_http_info(body, person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OnlineOrchestration body: (required)
        :param str person: Unique Person ID to filter by (required)
        :param str authorization: Optional SAS Signature within Header
        :param str sig: Optional SAS Signature within QueryString
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'person', 'authorization', 'sig']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method online_orchestration_trigger" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `online_orchestration_trigger`")  # noqa: E501
        # verify the required parameter 'person' is set
        if ('person' not in params or
                params['person'] is None):
            raise ValueError("Missing the required parameter `person` when calling `online_orchestration_trigger`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person' in params:
            path_params['person'] = params['person']  # noqa: E501

        query_params = []
        if 'sig' in params:
            query_params.append(('sig', params['sig']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Orchestration/Trigger/{person}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def profile_builder(self, body, authorization, person_id, **kwargs):  # noqa: E501
        """A Profile is a bespoke view of a customer's journey  # noqa: E501

        The profile view is created based on a view template that is provided as input.   **Sample request**: *GET /profileview?customer=123XX*   {   &nbsp;&nbsp;&nbsp;&nbsp;\"Name\": \"Test Template 2\",   &nbsp;&nbsp;&nbsp;&nbsp;\"DatapointCount\": 7,   &nbsp;&nbsp;&nbsp;&nbsp;\"Attributes\": [{   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Version\": \"0.1\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Event\": \"Add to Cart\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Metadata\": \"sku\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Limit\": 3,   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"DisplayName\": \"Items added\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"AggregationMode\": \"Value\"   &nbsp;&nbsp;&nbsp;&nbsp;}]   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profile_builder(body, authorization, person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProfileViewBuilderTemplate body: (required)
        :param str authorization: SAS Signature (required)
        :param str person_id: Identifies the person for whom the profile view is requested (required)
        :return: ProfileViewQueryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.profile_builder_with_http_info(body, authorization, person_id, **kwargs)  # noqa: E501
        else:
            (data) = self.profile_builder_with_http_info(body, authorization, person_id, **kwargs)  # noqa: E501
            return data

    def profile_builder_with_http_info(self, body, authorization, person_id, **kwargs):  # noqa: E501
        """A Profile is a bespoke view of a customer's journey  # noqa: E501

        The profile view is created based on a view template that is provided as input.   **Sample request**: *GET /profileview?customer=123XX*   {   &nbsp;&nbsp;&nbsp;&nbsp;\"Name\": \"Test Template 2\",   &nbsp;&nbsp;&nbsp;&nbsp;\"DatapointCount\": 7,   &nbsp;&nbsp;&nbsp;&nbsp;\"Attributes\": [{   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Version\": \"0.1\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Event\": \"Add to Cart\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Metadata\": \"sku\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Limit\": 3,   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"DisplayName\": \"Items added\",   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"AggregationMode\": \"Value\"   &nbsp;&nbsp;&nbsp;&nbsp;}]   }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.profile_builder_with_http_info(body, authorization, person_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProfileViewBuilderTemplate body: (required)
        :param str authorization: SAS Signature (required)
        :param str person_id: Identifies the person for whom the profile view is requested (required)
        :return: ProfileViewQueryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'authorization', 'person_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method profile_builder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `profile_builder`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `profile_builder`")  # noqa: E501
        # verify the required parameter 'person_id' is set
        if ('person_id' not in params or
                params['person_id'] is None):
            raise ValueError("Missing the required parameter `person_id` when calling `profile_builder`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'person_id' in params:
            query_params.append(('PersonId', params['person_id']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Profileview', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProfileViewQueryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def real_time_sse(self, **kwargs):  # noqa: E501
        """Real-time streaming enables API consumers to listen for events as it arrives part of the Journey, these may be transformed, value added / enriched and ready to be consumed or forwarded to an another destination  # noqa: E501

        Optionally accepts $filter to slice/dice further (ex: type eq 'Add to Cart')  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.real_time_sse(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sig: Optional SAS Signature within QueryString
        :param str authorization: Optional SAS Signature within Header
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.real_time_sse_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.real_time_sse_with_http_info(**kwargs)  # noqa: E501
            return data

    def real_time_sse_with_http_info(self, **kwargs):  # noqa: E501
        """Real-time streaming enables API consumers to listen for events as it arrives part of the Journey, these may be transformed, value added / enriched and ready to be consumed or forwarded to an another destination  # noqa: E501

        Optionally accepts $filter to slice/dice further (ex: type eq 'Add to Cart')  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.real_time_sse_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sig: Optional SAS Signature within QueryString
        :param str authorization: Optional SAS Signature within Header
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sig', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method real_time_sse" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sig' in params:
            query_params.append(('sig', params['sig']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/event-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Real-time', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def real_time_sse_person(self, person, **kwargs):  # noqa: E501
        """Real-time streaming enables API consumers to listen for events as it arrives part of the Journey, these may be transformed, value added / enriched and ready to be consumed or forwarded to an another destination  # noqa: E501

        Optionally accepts $filter to slice/dice further (ex: type eq 'Add to Cart')  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.real_time_sse_person(person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str person: Unique Person ID to filter by (required)
        :param str sig: Optional SAS Signature within QueryString
        :param str authorization: Optional SAS Signature within Header
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.real_time_sse_person_with_http_info(person, **kwargs)  # noqa: E501
        else:
            (data) = self.real_time_sse_person_with_http_info(person, **kwargs)  # noqa: E501
            return data

    def real_time_sse_person_with_http_info(self, person, **kwargs):  # noqa: E501
        """Real-time streaming enables API consumers to listen for events as it arrives part of the Journey, these may be transformed, value added / enriched and ready to be consumed or forwarded to an another destination  # noqa: E501

        Optionally accepts $filter to slice/dice further (ex: type eq 'Add to Cart')  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.real_time_sse_person_with_http_info(person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str person: Unique Person ID to filter by (required)
        :param str sig: Optional SAS Signature within QueryString
        :param str authorization: Optional SAS Signature within Header
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person', 'sig', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method real_time_sse_person" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person' is set
        if ('person' not in params or
                params['person'] is None):
            raise ValueError("Missing the required parameter `person` when calling `real_time_sse_person`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person' in params:
            path_params['person'] = params['person']  # noqa: E501

        query_params = []
        if 'sig' in params:
            query_params.append(('sig', params['sig']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/event-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Real-time/{person}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def settings(self, authorization, **kwargs):  # noqa: E501
        """API consumers can fully manage their Journey/CDP capabilities and settings using the Account Management endpoints  # noqa: E501

        Update, get data retention, destinations and more  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.settings(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :return: AccountSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.settings_with_http_info(authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.settings_with_http_info(authorization, **kwargs)  # noqa: E501
            return data

    def settings_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """API consumers can fully manage their Journey/CDP capabilities and settings using the Account Management endpoints  # noqa: E501

        Update, get data retention, destinations and more  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.settings_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: SAS Signature (required)
        :return: AccountSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_settings(self, body, authorization, **kwargs):  # noqa: E501
        """API consumers can fully manage their Journey/CDP capabilities and settings using the Account Management endpoints  # noqa: E501

        Update, get data retention, destinations and more  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_settings(body, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountSettings body: (required)
        :param str authorization: SAS Signature (required)
        :return: AccountSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_settings_with_http_info(body, authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.update_settings_with_http_info(body, authorization, **kwargs)  # noqa: E501
            return data

    def update_settings_with_http_info(self, body, authorization, **kwargs):  # noqa: E501
        """API consumers can fully manage their Journey/CDP capabilities and settings using the Account Management endpoints  # noqa: E501

        Update, get data retention, destinations and more  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_settings_with_http_info(body, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AccountSettings body: (required)
        :param str authorization: SAS Signature (required)
        :return: AccountSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_settings`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in params or
                params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `update_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Settings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def webex_walkin_sse(self, person, **kwargs):  # noqa: E501
        """SSE Channel for Webex Walkin Orchestration to Modify Journeys Midway  # noqa: E501

        Major browsers offer built-in class EventSource, with the EventSource object API consumers can automatically establishes a persistent connection and transparently allow for automatic reconnects with tunable retry timeout & Message ids to resume events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webex_walkin_sse(person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str person: Unique Person ID to filter by (required)
        :param str sig: Optional SAS Signature within QueryString
        :param str authorization: Optional SAS Signature within Header
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.webex_walkin_sse_with_http_info(person, **kwargs)  # noqa: E501
        else:
            (data) = self.webex_walkin_sse_with_http_info(person, **kwargs)  # noqa: E501
            return data

    def webex_walkin_sse_with_http_info(self, person, **kwargs):  # noqa: E501
        """SSE Channel for Webex Walkin Orchestration to Modify Journeys Midway  # noqa: E501

        Major browsers offer built-in class EventSource, with the EventSource object API consumers can automatically establishes a persistent connection and transparently allow for automatic reconnects with tunable retry timeout & Message ids to resume events.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webex_walkin_sse_with_http_info(person, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str person: Unique Person ID to filter by (required)
        :param str sig: Optional SAS Signature within QueryString
        :param str authorization: Optional SAS Signature within Header
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['person', 'sig', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method webex_walkin_sse" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'person' is set
        if ('person' not in params or
                params['person'] is None):
            raise ValueError("Missing the required parameter `person` when calling `webex_walkin_sse`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'person' in params:
            path_params['person'] = params['person']  # noqa: E501

        query_params = []
        if 'sig' in params:
            query_params.append(('sig', params['sig']))  # noqa: E501

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/event-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/Walkin/{person}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
